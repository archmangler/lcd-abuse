/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

// STM32F411 Register Base Addresses
#define RCC_BASE            (0x40023800UL)
#define GPIOA_BASE          (0x40020000UL)
#define GPIOB_BASE          (0x40020400UL)
#define I2C1_BASE           (0x40005400UL)

// Register Structures
#define RCC                 ((RCC_TypeDef *)RCC_BASE)
#define GPIOA               ((GPIO_TypeDef *)GPIOA_BASE)
#define GPIOB               ((GPIO_TypeDef *)GPIOB_BASE)
#define I2C1                ((I2C_TypeDef *)I2C1_BASE)

typedef struct {
    volatile uint32_t CR;           // RCC clock control register,                  offset: 0x00
    volatile uint32_t PLLCFGR;      // RCC PLL configuration register,             offset: 0x04
    volatile uint32_t CFGR;         // RCC clock configuration register,           offset: 0x08
    volatile uint32_t CIR;          // RCC clock interrupt register,               offset: 0x0C
    volatile uint32_t AHB1RSTR;     // RCC AHB1 peripheral reset register,         offset: 0x10
    volatile uint32_t AHB2RSTR;     // RCC AHB2 peripheral reset register,         offset: 0x14
    volatile uint32_t RESERVED0;    // Reserved,                                    offset: 0x18
    volatile uint32_t RESERVED1;    // Reserved,                                    offset: 0x1C
    volatile uint32_t APB1RSTR;     // RCC APB1 peripheral reset register,         offset: 0x20
    volatile uint32_t APB2RSTR;     // RCC APB2 peripheral reset register,         offset: 0x24
    volatile uint32_t RESERVED2[2]; // Reserved,                                    offset: 0x28-0x2C
    volatile uint32_t AHB1ENR;      // RCC AHB1 peripheral clock enable register,  offset: 0x30
    volatile uint32_t AHB2ENR;      // RCC AHB2 peripheral clock enable register,  offset: 0x34
    volatile uint32_t RESERVED3[2]; // Reserved,                                    offset: 0x38-0x3C
    volatile uint32_t APB1ENR;      // RCC APB1 peripheral clock enable register,  offset: 0x40
    volatile uint32_t APB2ENR;      // RCC APB2 peripheral clock enable register,  offset: 0x44
} RCC_TypeDef;

typedef struct {
    volatile uint32_t MODER;        // GPIO port mode register,                    offset: 0x00
    volatile uint32_t OTYPER;       // GPIO port output type register,             offset: 0x04
    volatile uint32_t OSPEEDR;      // GPIO port output speed register,            offset: 0x08
    volatile uint32_t PUPDR;        // GPIO port pull-up/pull-down register,       offset: 0x0C
    volatile uint32_t IDR;          // GPIO port input data register,              offset: 0x10
    volatile uint32_t ODR;          // GPIO port output data register,             offset: 0x14
    volatile uint32_t BSRR;         // GPIO port bit set/reset register,           offset: 0x18
    volatile uint32_t LCKR;         // GPIO port configuration lock register,      offset: 0x1C
    volatile uint32_t AFR[2];       // GPIO alternate function registers,          offset: 0x20-0x24
} GPIO_TypeDef;

typedef struct {
    volatile uint32_t CR1;          // I2C Control register 1,                     offset: 0x00
    volatile uint32_t CR2;          // I2C Control register 2,                     offset: 0x04
    volatile uint32_t OAR1;         // I2C Own address register 1,                 offset: 0x08
    volatile uint32_t OAR2;         // I2C Own address register 2,                 offset: 0x0C
    volatile uint32_t DR;           // I2C Data register,                          offset: 0x10
    volatile uint32_t SR1;          // I2C Status register 1,                      offset: 0x14
    volatile uint32_t SR2;          // I2C Status register 2,                      offset: 0x18
    volatile uint32_t CCR;          // I2C Clock control register,                 offset: 0x1C
    volatile uint32_t TRISE;        // I2C Rise time register,                     offset: 0x20
} I2C_TypeDef;

// Bit definitions - RCC
#define RCC_AHB1ENR_GPIOAEN         (1U << 0)   // GPIOA clock enable
#define RCC_AHB1ENR_GPIOBEN         (1U << 1)   // GPIOB clock enable
#define RCC_APB1ENR_I2C1EN          (1U << 21)  // I2C1 clock enable

// Bit definitions - GPIO
#define GPIO_MODER_MODER5_POS       (5 * 2)     // PA5 mode register position
#define GPIO_MODER_MODER5_MASK      (3U << GPIO_MODER_MODER5_POS)
#define GPIO_MODER_MODER5_OUTPUT    (1U << GPIO_MODER_MODER5_POS)
#define GPIO_ODR_OD5                (1U << 5)   // PA5 output data bit

// GPIO alternate function
#define GPIO_AFR_AF4                (4U)        // Alternate function 4 for I2C1
#define GPIO_AFR_AFR8_POS           ((8 % 8) * 4)  // PB8 alternate function position
#define GPIO_AFR_AFR9_POS           ((9 % 8) * 4)  // PB9 alternate function position

// Bit definitions - I2C
#define I2C_CR1_PE                  (1U << 0)   // Peripheral enable
#define I2C_CR1_START               (1U << 8)   // Start generation
#define I2C_CR1_STOP                (1U << 9)   // Stop generation
#define I2C_CR1_ACK                 (1U << 10)  // Acknowledge enable

#define I2C_SR1_SB                  (1U << 0)   // Start bit
#define I2C_SR1_ADDR                (1U << 1)   // Address sent
#define I2C_SR1_BTF                 (1U << 2)   // Byte transfer finished
#define I2C_SR1_TXE                 (1U << 7)   // Data register empty
#define I2C_SR2_BUSY                (1U << 1)   // Bus busy
#define I2C_SR2_MSL                 (1U << 0)   // Master/slave

// LCD I2C Configuration
#define LCD_I2C_ADDR                0x27        // Common I2C address (try 0x3F if this doesn't work)
#define LCD_BACKLIGHT               0x08        // P3 on PCF8574
#define LCD_EN                      0x04        // P2 on PCF8574
#define LCD_RW                      0x02        // P1 on PCF8574 (we keep RW=0)
#define LCD_RS                      0x01        // P0 on PCF8574

// SystemInit function - called from startup code
void SystemInit(void)
{
    // Enable HSI (16 MHz internal oscillator)
    RCC->CR |= (1U << 0);  // HSION bit
    
    // Wait for HSI ready
    while (!(RCC->CR & (1U << 1)));  // HSIRDY bit
    
    // Set HSI as system clock source
    RCC->CFGR &= ~(3U << 0);  // Clear SW bits
    RCC->CFGR |= (0U << 0);   // Set SW to HSI (00)
    
    // Wait for HSI to be selected
    while ((RCC->CFGR & (3U << 2)) != (0U << 2));  // Check SWS bits
}

// Simple delay function (approximate - assumes ~16MHz system clock)
void delay_ms(uint32_t ms)
{
    // Approximate delay: ~8000 loops per millisecond at 16MHz
    // Adjust multiplier based on actual clock speed
    for (uint32_t i = 0; i < ms * 8000; i++)
    {
        __asm volatile("nop");
    }
}

void delay_us(uint32_t us)
{
    // Approximate delay: ~8 loops per microsecond at 16MHz
    for (uint32_t i = 0; i < us * 8; i++)
    {
        __asm volatile("nop");
    }
}

// I2C1 Initialization - PB8 (SCL) and PB9 (SDA), Alternate Function 4
void I2C1_Init(void)
{
    // Enable clocks
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
    
    // Configure PB8 (SCL) and PB9 (SDA) as alternate function, open-drain, high speed
    // PB8 = SCL
    GPIOB->MODER &= ~(3U << (8 * 2));           // Clear mode bits
    GPIOB->MODER |= (2U << (8 * 2));            // Set alternate function mode (10)
    GPIOB->OTYPER |= (1U << 8);                 // Open-drain
    GPIOB->OSPEEDR |= (3U << (8 * 2));          // High speed
    GPIOB->PUPDR |= (1U << (8 * 2));            // Pull-up
    GPIOB->AFR[1] &= ~(0xF << ((8 - 8) * 4));   // Clear AF bits for PB8
    GPIOB->AFR[1] |= (GPIO_AFR_AF4 << ((8 - 8) * 4));  // Set AF4 for I2C1
    
    // PB9 = SDA
    GPIOB->MODER &= ~(3U << (9 * 2));           // Clear mode bits
    GPIOB->MODER |= (2U << (9 * 2));            // Set alternate function mode (10)
    GPIOB->OTYPER |= (1U << 9);                 // Open-drain
    GPIOB->OSPEEDR |= (3U << (9 * 2));          // High speed
    GPIOB->PUPDR |= (1U << (9 * 2));            // Pull-up
    GPIOB->AFR[1] &= ~(0xF << ((9 - 8) * 4));   // Clear AF bits for PB9
    GPIOB->AFR[1] |= (GPIO_AFR_AF4 << ((9 - 8) * 4));  // Set AF4 for I2C1
    
    // Reset I2C1
    RCC->APB1RSTR |= (1U << 21);                // Set I2C1 reset bit
    delay_us(10);
    RCC->APB1RSTR &= ~(1U << 21);               // Clear I2C1 reset bit
    
    // Configure I2C1 for 100kHz (Standard mode)
    // CCR calculation for Standard mode: CCR = APB1_clock / I2C_speed
    // Assuming 16MHz APB1: CCR = 16000000 / 100000 = 160
    I2C1->CR2 = 16;                             // Set peripheral clock frequency (16MHz) in MHz
    I2C1->CCR = 160;                            // Clock control register (100kHz Standard mode)
    I2C1->TRISE = 17;                           // Maximum rise time (1000ns + 1)
    I2C1->CR1 |= I2C_CR1_PE;                    // Enable peripheral
}

// Wait for I2C flag
static void I2C_WaitFlag(uint32_t flag, uint32_t status)
{
    uint32_t timeout = 10000;
    while (((I2C1->SR1 & flag) == status) && (--timeout));
}

// I2C Start condition
static void I2C_Start(void)
{
    I2C1->CR1 |= I2C_CR1_START;
    I2C_WaitFlag(I2C_SR1_SB, 0);
}

// I2C Stop condition
static void I2C_Stop(void)
{
    I2C1->CR1 |= I2C_CR1_STOP;
}

// I2C Send address
static void I2C_SendAddress(uint8_t address, uint8_t read)
{
    I2C1->DR = (address << 1) | (read ? 1 : 0);
    I2C_WaitFlag(I2C_SR1_ADDR, 0);
    volatile uint32_t dummy = I2C1->SR2;        // Read SR2 to clear ADDR flag
    (void)dummy;
}

// I2C Send byte
static void I2C_SendByte(uint8_t data)
{
    I2C_WaitFlag(I2C_SR1_TXE, 0);
    I2C1->DR = data;
    I2C_WaitFlag(I2C_SR1_BTF, 0);
}

// PCF8574 write (sends one byte to the I2C LCD backpack)
static void pcf8574_write(uint8_t data)
{
    I2C_Start();
    I2C_SendAddress(LCD_I2C_ADDR, 0);           // Write mode
    I2C_SendByte(data);
    I2C_Stop();
    delay_us(100);                               // Small delay after transmission
}

// Pulse enable to latch data into LCD
static void lcd_pulse_enable(uint8_t data)
{
    pcf8574_write(data | LCD_EN);
    delay_us(1);
    pcf8574_write(data & ~LCD_EN);
    delay_us(50);
}

// Send 4 bits (upper nibble in bits P4..P7)
static void lcd_write4(uint8_t nibble_with_ctrl)
{
    pcf8574_write(nibble_with_ctrl);
    lcd_pulse_enable(nibble_with_ctrl);
}

// Send full byte as two nibbles
static void lcd_send(uint8_t value, uint8_t mode_rs)
{
    uint8_t high = (value & 0xF0);
    uint8_t low  = (value << 4) & 0xF0;
    uint8_t ctrl = LCD_BACKLIGHT | (mode_rs ? LCD_RS : 0x00); // RW=0 always
    
    lcd_write4(high | ctrl);
    lcd_write4(low | ctrl);
}

// LCD command
static void lcd_cmd(uint8_t cmd)
{
    lcd_send(cmd, 0);
    if (cmd == 0x01 || cmd == 0x02) delay_ms(2); // Clear/home need >1.5ms
}

// LCD data
static void lcd_data(uint8_t data)
{
    lcd_send(data, 1);
}

// LCD initialization
static void lcd_init(void)
{
    delay_ms(50); // LCD power-up delay
    
    // Force 4-bit init sequence (per HD44780 datasheet)
    uint8_t ctrl = LCD_BACKLIGHT; // RS=0, RW=0
    lcd_write4(0x30 | ctrl); delay_ms(5);
    lcd_write4(0x30 | ctrl); delay_us(200);
    lcd_write4(0x30 | ctrl); delay_us(200);
    lcd_write4(0x20 | ctrl); delay_us(200); // 4-bit mode
    
    // Function set: 4-bit, 2-line (works for 20x4 too), 5x8 font
    lcd_cmd(0x28);
    
    // Display ON, cursor OFF, blink OFF
    lcd_cmd(0x0C);
    
    // Clear display
    lcd_cmd(0x01);
    
    // Entry mode: increment, no shift
    lcd_cmd(0x06);
}

// Set cursor: row 0..3, col 0..19
static void lcd_set_cursor(uint8_t row, uint8_t col)
{
    static const uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
    lcd_cmd(0x80 | (row_offsets[row] + col));
}

// Print string
static void lcd_print(const char *s)
{
    while (*s) lcd_data((uint8_t)*s++);
}

int main(void)
{
    // Enable GPIOA clock
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    
    // Configure PA5 as output (Nucleo-F411RE user LED LD2 - heartbeat)
    GPIOA->MODER &= ~GPIO_MODER_MODER5_MASK;        // Clear mode bits for PA5
    GPIOA->MODER |= GPIO_MODER_MODER5_OUTPUT;       // Set PA5 to output mode (01)
    
    // Configure output type: push-pull (0 = default, already cleared)
    GPIOA->OTYPER &= ~(1U << 5);
    
    // Configure output speed: low (optional, 0 = default)
    GPIOA->OSPEEDR &= ~(3U << GPIO_MODER_MODER5_POS);
    
    // No pull-up/pull-down (optional, 0 = default)
    GPIOA->PUPDR &= ~(3U << GPIO_MODER_MODER5_POS);
    
    // Initialize I2C1 for LCD
    I2C1_Init();
    
    // Initialize LCD
    delay_ms(100);  // Give I2C time to stabilize
    lcd_init();
    delay_ms(10);
    
    // Display initial message
    lcd_set_cursor(0, 0);
    lcd_print("STM32F411RE");
    lcd_set_cursor(1, 0);
    lcd_print("LCD 20x4 I2C");
    lcd_set_cursor(2, 0);
    lcd_print("Heartbeat: OK");
    lcd_set_cursor(3, 0);
    lcd_print("System Ready");
    
    // Main loop - blink LED heartbeat and update LCD
    uint32_t heartbeat_counter = 0;
    while (1)
    {
        // Toggle PA5 (LED heartbeat) every 500ms
        GPIOA->ODR ^= GPIO_ODR_OD5;
        
        heartbeat_counter++;
        if (heartbeat_counter >= 10) // Every 5 seconds (10 * 500ms)
        {
            heartbeat_counter = 0;
            // Update heartbeat indicator on LCD
            lcd_set_cursor(2, 12);
            lcd_print("OK");
        }
        
        // Delay ~500ms
        delay_ms(500);
    }
}
