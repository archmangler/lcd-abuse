/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

// STM32F411 Register Base Addresses
#define RCC_BASE            (0x40023800UL)
#define GPIOA_BASE          (0x40020000UL)
#define GPIOB_BASE          (0x40020400UL)
#define GPIOC_BASE          (0x40020800UL)
#define I2C1_BASE           (0x40005400UL)

// Register Structures
#define RCC                 ((RCC_TypeDef *)RCC_BASE)
#define GPIOA               ((GPIO_TypeDef *)GPIOA_BASE)
#define GPIOB               ((GPIO_TypeDef *)GPIOB_BASE)
#define GPIOC               ((GPIO_TypeDef *)GPIOC_BASE)
#define I2C1                ((I2C_TypeDef *)I2C1_BASE)

typedef struct {
    volatile uint32_t CR;           // RCC clock control register,                  offset: 0x00
    volatile uint32_t PLLCFGR;      // RCC PLL configuration register,             offset: 0x04
    volatile uint32_t CFGR;         // RCC clock configuration register,           offset: 0x08
    volatile uint32_t CIR;          // RCC clock interrupt register,               offset: 0x0C
    volatile uint32_t AHB1RSTR;     // RCC AHB1 peripheral reset register,         offset: 0x10
    volatile uint32_t AHB2RSTR;     // RCC AHB2 peripheral reset register,         offset: 0x14
    volatile uint32_t RESERVED0;    // Reserved,                                    offset: 0x18
    volatile uint32_t RESERVED1;    // Reserved,                                    offset: 0x1C
    volatile uint32_t APB1RSTR;     // RCC APB1 peripheral reset register,         offset: 0x20
    volatile uint32_t APB2RSTR;     // RCC APB2 peripheral reset register,         offset: 0x24
    volatile uint32_t RESERVED2[2]; // Reserved,                                    offset: 0x28-0x2C
    volatile uint32_t AHB1ENR;      // RCC AHB1 peripheral clock enable register,  offset: 0x30
    volatile uint32_t AHB2ENR;      // RCC AHB2 peripheral clock enable register,  offset: 0x34
    volatile uint32_t RESERVED3[2]; // Reserved,                                    offset: 0x38-0x3C
    volatile uint32_t APB1ENR;      // RCC APB1 peripheral clock enable register,  offset: 0x40
    volatile uint32_t APB2ENR;      // RCC APB2 peripheral clock enable register,  offset: 0x44
} RCC_TypeDef;

typedef struct {
    volatile uint32_t MODER;        // GPIO port mode register,                    offset: 0x00
    volatile uint32_t OTYPER;       // GPIO port output type register,             offset: 0x04
    volatile uint32_t OSPEEDR;      // GPIO port output speed register,            offset: 0x08
    volatile uint32_t PUPDR;        // GPIO port pull-up/pull-down register,       offset: 0x0C
    volatile uint32_t IDR;          // GPIO port input data register,              offset: 0x10
    volatile uint32_t ODR;          // GPIO port output data register,             offset: 0x14
    volatile uint32_t BSRR;         // GPIO port bit set/reset register,           offset: 0x18
    volatile uint32_t LCKR;         // GPIO port configuration lock register,      offset: 0x1C
    volatile uint32_t AFR[2];       // GPIO alternate function registers,          offset: 0x20-0x24
} GPIO_TypeDef;

typedef struct {
    volatile uint32_t CR1;          // I2C Control register 1,                     offset: 0x00
    volatile uint32_t CR2;          // I2C Control register 2,                     offset: 0x04
    volatile uint32_t OAR1;         // I2C Own address register 1,                 offset: 0x08
    volatile uint32_t OAR2;         // I2C Own address register 2,                 offset: 0x0C
    volatile uint32_t DR;           // I2C Data register,                          offset: 0x10
    volatile uint32_t SR1;          // I2C Status register 1,                      offset: 0x14
    volatile uint32_t SR2;          // I2C Status register 2,                      offset: 0x18
    volatile uint32_t CCR;          // I2C Clock control register,                 offset: 0x1C
    volatile uint32_t TRISE;        // I2C Rise time register,                     offset: 0x20
} I2C_TypeDef;

// Bit definitions - RCC
#define RCC_AHB1ENR_GPIOAEN         (1U << 0)   // GPIOA clock enable
#define RCC_AHB1ENR_GPIOBEN         (1U << 1)   // GPIOB clock enable
#define RCC_AHB1ENR_GPIOCEN         (1U << 2)   // GPIOC clock enable
#define RCC_APB1ENR_I2C1EN          (1U << 21)  // I2C1 clock enable

// Optocoupler pin definitions (PC6-PC9)
// PC7: optocoupler input-4 : motor-A Forward input
// PC9: optocoupler input-3: motor-A Reverse Input
// PC6: optocoupler input-2: motor-B forward input
// PC8: optocoupler input-1: motor-B reverse input
#define OPTOC_PC6           (6)   // Motor-B reverse
#define OPTOC_PC7           (7)   // Motor-A forward
#define OPTOC_PC8           (8)   // Motor-B forward
#define OPTOC_PC9           (9)   // Motor-A reverse

// Bit definitions - GPIO
#define GPIO_MODER_MODER5_POS       (5 * 2)     // PA5 mode register position
#define GPIO_MODER_MODER5_MASK      (3U << GPIO_MODER_MODER5_POS)
#define GPIO_MODER_MODER5_OUTPUT    (1U << GPIO_MODER_MODER5_POS)
#define GPIO_ODR_OD5                (1U << 5)   // PA5 output data bit

// GPIO alternate function
#define GPIO_AFR_AF4                (4U)        // Alternate function 4 for I2C1
#define GPIO_AFR_AFR8_POS           ((8 % 8) * 4)  // PB8 alternate function position
#define GPIO_AFR_AFR9_POS           ((9 % 8) * 4)  // PB9 alternate function position

// Bit definitions - I2C
#define I2C_CR1_PE                  (1U << 0)   // Peripheral enable
#define I2C_CR1_START               (1U << 8)   // Start generation
#define I2C_CR1_STOP                (1U << 9)   // Stop generation
#define I2C_CR1_ACK                 (1U << 10)  // Acknowledge enable

#define I2C_SR1_SB                  (1U << 0)   // Start bit
#define I2C_SR1_ADDR                (1U << 1)   // Address sent
#define I2C_SR1_BTF                 (1U << 2)   // Byte transfer finished
#define I2C_SR1_TXE                 (1U << 7)   // Data register empty
#define I2C_SR2_BUSY                (1U << 1)   // Bus busy
#define I2C_SR2_MSL                 (1U << 0)   // Master/slave

// LCD I2C Configuration
#define LCD_I2C_ADDR                0x27        // Common I2C address (try 0x3F if this doesn't work)
#define LCD_BACKLIGHT               0x08        // P3 on PCF8574
#define LCD_EN                      0x04        // P2 on PCF8574
#define LCD_RW                      0x02        // P1 on PCF8574 (we keep RW=0)
#define LCD_RS                      0x01        // P0 on PCF8574

// SystemInit function - called from startup code
void SystemInit(void)
{
    // Enable HSI (16 MHz internal oscillator)
    RCC->CR |= (1U << 0);  // HSION bit
    
    // Wait for HSI ready
    while (!(RCC->CR & (1U << 1)));  // HSIRDY bit
    
    // Set HSI as system clock source
    RCC->CFGR &= ~(3U << 0);  // Clear SW bits
    RCC->CFGR |= (0U << 0);   // Set SW to HSI (00)
    
    // Wait for HSI to be selected
    while ((RCC->CFGR & (3U << 2)) != (0U << 2));  // Check SWS bits
}

// Simple delay function (approximate - assumes ~16MHz system clock)
void delay_ms(uint32_t ms)
{
    // Approximate delay: ~8000 loops per millisecond at 16MHz
    // Adjust multiplier based on actual clock speed
    for (uint32_t i = 0; i < ms * 8000; i++)
    {
        __asm volatile("nop");
    }
}

// Optocoupler control functions
// Initialize optocoupler GPIO pins (PC6, PC7, PC8, PC9)
void Optocoupler_Init(void)
{
    // Enable GPIOC clock
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN;
    
    // Configure PC6, PC7, PC8, PC9 as outputs
    // PC6 - Motor-B reverse
    GPIOC->MODER &= ~(3U << (OPTOC_PC6 * 2));
    GPIOC->MODER |= (1U << (OPTOC_PC6 * 2));      // Output mode
    GPIOC->OTYPER &= ~(1U << OPTOC_PC6);          // Push-pull
    GPIOC->OSPEEDR |= (1U << (OPTOC_PC6 * 2));    // Medium speed
    GPIOC->PUPDR &= ~(3U << (OPTOC_PC6 * 2));     // No pull-up/pull-down
    
    // PC7 - Motor-A forward
    GPIOC->MODER &= ~(3U << (OPTOC_PC7 * 2));
    GPIOC->MODER |= (1U << (OPTOC_PC7 * 2));      // Output mode
    GPIOC->OTYPER &= ~(1U << OPTOC_PC7);          // Push-pull
    GPIOC->OSPEEDR |= (1U << (OPTOC_PC7 * 2));    // Medium speed
    GPIOC->PUPDR &= ~(3U << (OPTOC_PC7 * 2));     // No pull-up/pull-down
    
    // PC8 - Motor-B forward
    GPIOC->MODER &= ~(3U << (OPTOC_PC8 * 2));
    GPIOC->MODER |= (1U << (OPTOC_PC8 * 2));      // Output mode
    GPIOC->OTYPER &= ~(1U << OPTOC_PC8);          // Push-pull
    GPIOC->OSPEEDR |= (1U << (OPTOC_PC8 * 2));    // Medium speed
    GPIOC->PUPDR &= ~(3U << (OPTOC_PC8 * 2));     // No pull-up/pull-down
    
    // PC9 - Motor-A reverse
    GPIOC->MODER &= ~(3U << (OPTOC_PC9 * 2));
    GPIOC->MODER |= (1U << (OPTOC_PC9 * 2));      // Output mode
    GPIOC->OTYPER &= ~(1U << OPTOC_PC9);          // Push-pull
    GPIOC->OSPEEDR |= (1U << (OPTOC_PC9 * 2));    // Medium speed
    GPIOC->PUPDR &= ~(3U << (OPTOC_PC9 * 2));     // No pull-up/pull-down
    
    // Ensure all optocoupler pins are OFF initially
    Optocoupler_AllOff();
}

// Turn off all optocoupler outputs (safety function)
void Optocoupler_AllOff(void)
{
    // Clear PC6, PC7, PC8, PC9 (set to LOW)
    GPIOC->BSRR = (1U << (OPTOC_PC6 + 16));  // Reset PC6
    GPIOC->BSRR = (1U << (OPTOC_PC7 + 16));  // Reset PC7
    GPIOC->BSRR = (1U << (OPTOC_PC8 + 16));  // Reset PC8
    GPIOC->BSRR = (1U << (OPTOC_PC9 + 16));  // Reset PC9
}

// Set a specific optocoupler pin (turn on one channel)
// channel: 1=PC8 (Motor-B reverse), 2=PC6 (Motor-B forward), 
//          3=PC9 (Motor-A reverse), 4=PC7 (Motor-A forward)
void Optocoupler_Set(uint8_t channel)
{
    // First, turn off all channels for safety
    Optocoupler_AllOff();
    
    // Then turn on the requested channel
    switch(channel)
    {
        case 1:  // Motor-B reverse (PC8)
            GPIOC->BSRR = (1U << OPTOC_PC8);  // Set PC8 HIGH
            break;
        case 2:  // Motor-B forward (PC6)
            GPIOC->BSRR = (1U << OPTOC_PC6);  // Set PC6 HIGH
            break;
        case 3:  // Motor-A reverse (PC9)
            GPIOC->BSRR = (1U << OPTOC_PC9);  // Set PC9 HIGH
            break;
        case 4:  // Motor-A forward (PC7)
            GPIOC->BSRR = (1U << OPTOC_PC7);  // Set PC7 HIGH
            break;
        default:
            // Invalid channel, do nothing (all remain off)
            break;
    }
}

// Test sequence: Activate each optocoupler channel for 1 second sequentially
// Only one channel is active at a time to prevent driver overload
void Optocoupler_TestSequence(void)
{
    // Turn off all channels first
    Optocoupler_AllOff();
    delay_ms(100);
    
    // Test sequence: Each channel active for 1 second
    // Channel 1: Motor-B reverse (PC8)
    Optocoupler_Set(1);
    delay_ms(1000);
    
    // Channel 2: Motor-B forward (PC6)
    Optocoupler_Set(2);
    delay_ms(1000);
    
    // Channel 3: Motor-A reverse (PC9)
    Optocoupler_Set(3);
    delay_ms(1000);
    
    // Channel 4: Motor-A forward (PC7)
    Optocoupler_Set(4);
    delay_ms(1000);
    
    // Turn off all channels after test
    Optocoupler_AllOff();
    delay_ms(100);
}

void delay_us(uint32_t us)
{
    // Approximate delay: ~8 loops per microsecond at 16MHz
    for (uint32_t i = 0; i < us * 8; i++)
    {
        __asm volatile("nop");
    }
}

// I2C1 Initialization - PB8 (SCL) and PB9 (SDA), Alternate Function 4
void I2C1_Init(void)
{
    // Enable clocks
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
    
    // Configure PB8 (SCL) and PB9 (SDA) as alternate function, open-drain, high speed
    // PB8 = SCL
    GPIOB->MODER &= ~(3U << (8 * 2));           // Clear mode bits
    GPIOB->MODER |= (2U << (8 * 2));            // Set alternate function mode (10)
    GPIOB->OTYPER |= (1U << 8);                 // Open-drain
    GPIOB->OSPEEDR |= (3U << (8 * 2));          // High speed
    GPIOB->PUPDR |= (1U << (8 * 2));            // Pull-up
    GPIOB->AFR[1] &= ~(0xF << ((8 - 8) * 4));   // Clear AF bits for PB8
    GPIOB->AFR[1] |= (GPIO_AFR_AF4 << ((8 - 8) * 4));  // Set AF4 for I2C1
    
    // PB9 = SDA
    GPIOB->MODER &= ~(3U << (9 * 2));           // Clear mode bits
    GPIOB->MODER |= (2U << (9 * 2));            // Set alternate function mode (10)
    GPIOB->OTYPER |= (1U << 9);                 // Open-drain
    GPIOB->OSPEEDR |= (3U << (9 * 2));          // High speed
    GPIOB->PUPDR |= (1U << (9 * 2));            // Pull-up
    GPIOB->AFR[1] &= ~(0xF << ((9 - 8) * 4));   // Clear AF bits for PB9
    GPIOB->AFR[1] |= (GPIO_AFR_AF4 << ((9 - 8) * 4));  // Set AF4 for I2C1
    
    // Reset I2C1
    RCC->APB1RSTR |= (1U << 21);                // Set I2C1 reset bit
    delay_us(10);
    RCC->APB1RSTR &= ~(1U << 21);               // Clear I2C1 reset bit
    
    // Configure I2C1 for 100kHz (Standard mode)
    // CCR calculation for Standard mode: CCR = APB1_clock / I2C_speed
    // Assuming 16MHz APB1: CCR = 16000000 / 100000 = 160
    I2C1->CR2 = 16;                             // Set peripheral clock frequency (16MHz) in MHz
    I2C1->CCR = 160;                            // Clock control register (100kHz Standard mode)
    I2C1->TRISE = 17;                           // Maximum rise time (1000ns + 1)
    I2C1->CR1 |= I2C_CR1_PE;                    // Enable peripheral
}

// Wait for I2C flag
static void I2C_WaitFlag(uint32_t flag, uint32_t status)
{
    uint32_t timeout = 10000;
    while (((I2C1->SR1 & flag) == status) && (--timeout));
}

// I2C Start condition
static void I2C_Start(void)
{
    I2C1->CR1 |= I2C_CR1_START;
    I2C_WaitFlag(I2C_SR1_SB, 0);
}

// I2C Stop condition
static void I2C_Stop(void)
{
    I2C1->CR1 |= I2C_CR1_STOP;
}

// I2C Send address
static void I2C_SendAddress(uint8_t address, uint8_t read)
{
    I2C1->DR = (address << 1) | (read ? 1 : 0);
    I2C_WaitFlag(I2C_SR1_ADDR, 0);
    volatile uint32_t dummy = I2C1->SR2;        // Read SR2 to clear ADDR flag
    (void)dummy;
}

// I2C Send byte
static void I2C_SendByte(uint8_t data)
{
    I2C_WaitFlag(I2C_SR1_TXE, 0);
    I2C1->DR = data;
    I2C_WaitFlag(I2C_SR1_BTF, 0);
}

// PCF8574 write (sends one byte to the I2C LCD backpack)
static void pcf8574_write(uint8_t data)
{
    I2C_Start();
    I2C_SendAddress(LCD_I2C_ADDR, 0);           // Write mode
    I2C_SendByte(data);
    I2C_Stop();
    delay_us(100);                               // Small delay after transmission
}

// Pulse enable to latch data into LCD
static void lcd_pulse_enable(uint8_t data)
{
    pcf8574_write(data | LCD_EN);
    delay_us(1);
    pcf8574_write(data & ~LCD_EN);
    delay_us(50);
}

// Send 4 bits (upper nibble in bits P4..P7)
static void lcd_write4(uint8_t nibble_with_ctrl)
{
    pcf8574_write(nibble_with_ctrl);
    lcd_pulse_enable(nibble_with_ctrl);
}

// Send full byte as two nibbles
static void lcd_send(uint8_t value, uint8_t mode_rs)
{
    uint8_t high = (value & 0xF0);
    uint8_t low  = (value << 4) & 0xF0;
    uint8_t ctrl = LCD_BACKLIGHT | (mode_rs ? LCD_RS : 0x00); // RW=0 always
    
    lcd_write4(high | ctrl);
    lcd_write4(low | ctrl);
}

// LCD command
static void lcd_cmd(uint8_t cmd)
{
    lcd_send(cmd, 0);
    if (cmd == 0x01 || cmd == 0x02) delay_ms(2); // Clear/home need >1.5ms
}

// LCD data
static void lcd_data(uint8_t data)
{
    lcd_send(data, 1);
}

// LCD initialization
static void lcd_init(void)
{
    delay_ms(50); // LCD power-up delay
    
    // Force 4-bit init sequence (per HD44780 datasheet)
    uint8_t ctrl = LCD_BACKLIGHT; // RS=0, RW=0
    lcd_write4(0x30 | ctrl); delay_ms(5);
    lcd_write4(0x30 | ctrl); delay_us(200);
    lcd_write4(0x30 | ctrl); delay_us(200);
    lcd_write4(0x20 | ctrl); delay_us(200); // 4-bit mode
    
    // Function set: 4-bit, 2-line (works for 20x4 too), 5x8 font
    lcd_cmd(0x28);
    
    // Display ON, cursor OFF, blink OFF
    lcd_cmd(0x0C);
    
    // Clear display
    lcd_cmd(0x01);
    
    // Entry mode: increment, no shift
    lcd_cmd(0x06);
}

// Set cursor: row 0..3, col 0..19
static void lcd_set_cursor(uint8_t row, uint8_t col)
{
    static const uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
    lcd_cmd(0x80 | (row_offsets[row] + col));
}

// Print string
static void lcd_print(const char *s)
{
    while (*s) lcd_data((uint8_t)*s++);
}

// Clear a specific line by filling with spaces
static void lcd_clear_line(uint8_t row)
{
    lcd_set_cursor(row, 0);
    for (uint8_t i = 0; i < 20; i++)
    {
        lcd_data(' ');
    }
    lcd_set_cursor(row, 0);
}

// Scroll display up by one line
static void lcd_scroll_up(void)
{
    // Read lines 1, 2, 3 and move them to lines 0, 1, 2
    // We'll use a simple approach: clear line 0, then shift content
    // Actually, simpler: just scroll the cursor addresses
    // HD44780 doesn't have hardware scroll, so we'll manually shift
    
    // For now, we'll clear line 0 and move cursor to line 3
    // The caller will handle writing new content
    lcd_cmd(0x18);  // Display shift left (can help with scrolling effect)
}

// Clear entire display
static void lcd_clear(void)
{
    lcd_cmd(0x01);
    delay_ms(2);  // Clear command needs >1.5ms
}

// Stream text character by character with line wrapping and scrolling
static void lcd_stream_text(const char *text, uint32_t char_delay_ms)
{
    static uint8_t current_row = 0;
    static uint8_t current_col = 0;
    
    while (*text)
    {
        char c = *text++;
        
        // Handle newlines
        if (c == '\n')
        {
            current_row++;
            current_col = 0;
            
            // If we've filled all 4 rows, scroll up
            if (current_row >= 4)
            {
                // Scroll: move lines 1,2,3 up to 0,1,2, clear line 3
                // Since HD44780 doesn't have easy scroll, we'll clear and restart from top
                // For continuous streaming, we'll wrap to top after line 3
                lcd_clear();
                current_row = 0;
                current_col = 0;
                delay_ms(char_delay_ms * 3); // Pause before restarting
            }
            else
            {
                lcd_set_cursor(current_row, current_col);
            }
            continue;
        }
        
        // Handle regular characters
        if (current_col >= 20)
        {
            // Line wrap
            current_row++;
            current_col = 0;
            
            // If we've filled all 4 rows, clear and restart
            if (current_row >= 4)
            {
                lcd_clear();
                current_row = 0;
                current_col = 0;
                delay_ms(char_delay_ms * 3); // Pause before restarting
            }
            else
            {
                lcd_set_cursor(current_row, current_col);
            }
        }
        
        // Print character
        lcd_data((uint8_t)c);
        current_col++;
        
        // Delay between characters for readability
        delay_ms(char_delay_ms);
    }
}

// Stream text continuously in a loop with proper scrolling
static void lcd_stream_continuous(const char *text, uint32_t char_delay_ms)
{
    static char display_buffer[4][21]; // 4 lines, 20 chars + null terminator
    static uint8_t line_index = 0;
    static uint8_t char_pos = 0;
    
    const char *text_ptr = text;
    
    while (*text_ptr)
    {
        char c = *text_ptr++;
        
        // Handle newlines and line breaks
        if (c == '\n' || char_pos >= 20)
        {
            // Terminate current line
            display_buffer[line_index][char_pos] = '\0';
            line_index++;
            char_pos = 0;
            
            // If we've filled all 4 lines, scroll up
            if (line_index >= 4)
            {
                // Display all 4 lines
                for (uint8_t i = 0; i < 4; i++)
                {
                    lcd_set_cursor(i, 0);
                    lcd_print(display_buffer[i]);
                    // Clear rest of line if needed
                    uint8_t len = 0;
                    while (display_buffer[i][len] && len < 20) len++;
                    for (uint8_t j = len; j < 20; j++)
                    {
                        lcd_data(' ');
                    }
                }
                
                delay_ms(char_delay_ms * 20); // Pause to read
                
                // Shift lines up (move line 1->0, 2->1, 3->2)
                for (uint8_t i = 0; i < 3; i++)
                {
                    for (uint8_t j = 0; j < 21; j++)
                    {
                        display_buffer[i][j] = display_buffer[i+1][j];
                    }
                }
                // Clear line 3
                for (uint8_t j = 0; j < 21; j++)
                {
                    display_buffer[3][j] = '\0';
                }
                line_index = 3; // Continue writing to line 3
            }
            
            if (c == '\n')
            {
                continue; // Skip the newline character
            }
        }
        
        // Store character in current line
        if (char_pos < 20)
        {
            display_buffer[line_index][char_pos++] = c;
        }
    }
    
    // Display any remaining text
    if (line_index < 4 && char_pos > 0)
    {
        display_buffer[line_index][char_pos] = '\0';
        for (uint8_t i = 0; i <= line_index; i++)
        {
            lcd_set_cursor(i, 0);
            lcd_print(display_buffer[i]);
            // Clear rest of line
            uint8_t len = 0;
            while (display_buffer[i][len] && len < 20) len++;
            for (uint8_t j = len; j < 20; j++)
            {
                lcd_data(' ');
            }
        }
    }
}

// Simple continuous text streaming with line wrapping
static void lcd_stream_simple(const char *text, uint32_t char_delay_ms)
{
    uint8_t row = 0;
    uint8_t col = 0;
    
    while (*text)
    {
        char c = *text++;
        
        // Skip carriage returns
        if (c == '\r')
        {
            continue;
        }
        
        // Handle newlines
        if (c == '\n')
        {
            row++;
            col = 0;
            if (row >= 4)
            {
                // Scroll: clear display and start over
                lcd_clear();
                row = 0;
                col = 0;
                delay_ms(char_delay_ms * 10); // Pause before restart
            }
            lcd_set_cursor(row, col);
            continue;
        }
        
        // Wrap at end of line
        if (col >= 20)
        {
            row++;
            col = 0;
            if (row >= 4)
            {
                // Scroll: clear display and start over
                lcd_clear();
                row = 0;
                col = 0;
                delay_ms(char_delay_ms * 10); // Pause before restart
            }
            lcd_set_cursor(row, col);
        }
        
        // Print character
        lcd_data((uint8_t)c);
        col++;
        
        // Small delay for readability
        if (char_delay_ms > 0)
        {
            delay_ms(char_delay_ms);
        }
    }
}

// Story text to stream continuously
static const char story_text[] = 
    "Escape from Planet Metron!\n\n"
    "Far, far away, where the stars shine like tiny lanterns, there was a strange planet called Planet Metron.\n\n"
    "Planet Metron was not kind.\n\n"
    "It was made of metal instead of grass, and its mountains were sharp and cold. Long tunnels ran through it like the inside of a giant machine. The planet hummed all the time, like it was breathing in its sleep.\n\n"
    "On this planet lived two children.\n\n"
    "A brother named Troy, and his little sister Irana.\n\n"
    "They had lived there for as long as they could remember.\n\n"
    "Planet Metron was ruled by the Archons—tall robot creatures made of dark metal and shadow. They had glowing eyes and moved without making a sound. The Archons watched everything. They did not laugh. They did not smile. They did not sleep.\n\n"
    "Their job was to make sure no one ever left.\n\n"
    "Troy and Irana were kept in an old room with broken windows and flickering lights. At night, Troy would listen to the planet's humming and feel scared.\n\n"
    "But Irana would whisper, \"It's okay. I'm listening.\"\n\n"
    "Irana was very good at listening.\n\n"
    "She could tell when the Archons were nearby and when the planet was changing its mind. She could feel when doors would open and when hallways would twist.\n\n"
    "One day, the humming changed.\n\n"
    "The planet shook gently, like it had a bad dream.\n\n"
    "Irana sat up. \"Troy,\" she said quietly, \"the planet is busy.\"\n\n"
    "\"Busy with what?\" Troy asked.\n\n"
    "\"Busy watching something else,\" she replied. \"That means it's our turn.\"\n\n"
    "She pulled out a small glowing piece of metal she had found long ago. It blinked like a tiny star.\n\n"
    "\"This can help us get out,\" she said.\n\n"
    "Troy's heart beat fast. \"Really?\"\n\n"
    "Irana nodded. \"We have to be brave.\"\n\n"
    "They crawled through small tunnels and tiptoed through long halls. The lights flickered, and far away they heard the soft click-click of Archons moving.\n\n"
    "Suddenly, an Archon stepped in front of them.\n\n"
    "It was tall and scary, and its eyes glowed bright.\n\n"
    "Troy didn't think. He just acted.\n\n"
    "He threw a small flashing spike, and POP! A bright light filled the hallway. The Archon stumbled and fell apart into quiet pieces.\n\n"
    "Irana grabbed Troy's hand. \"Come on!\"\n\n"
    "At last, they reached the outside of the planet.\n\n"
    "There, sitting on a metal platform, was a tiny spaceship. It was old and scratched and looked tired ... but it was real.\n\n"
    "As they ran toward it, the planet tried to stop them. Metal arms reached up from the ground, trying to pull them back.\n\n"
    "One grabbed Irana's foot.\n\n"
    "\"Irana!\" Troy cried.\n\n"
    "\"I'm okay!\" she said, cutting it away. \"Keep going!\"\n\n"
    "Then something very big appeared.\n\n"
    "The biggest Archon of all.\n\n"
    "It stood between them and the ship, darker than the others, with glowing symbols floating around its head. Everything felt slow and heavy.\n\n"
    "Troy couldn't move.\n\n"
    "Irana looked at her brother and knew what she had to do.\n\n"
    "She squeezed the glowing metal piece in her hand and pressed it hard.\n\n"
    "A bright, warm light burst out, like a tiny sun.\n\n"
    "The big Archon screamed without sound and disappeared.\n\n"
    "The ship's door opened.\n\n"
    "They ran inside.\n\n"
    "The ship lifted off just as Planet Metron began to close itself up again. The Archons watched from below, their shadows stretching but never reaching.\n\n"
    "Soon, the stars filled the window.\n\n"
    "The ship floated quietly.\n\n"
    "Irana leaned against Troy. \"We did it,\" she said softly.\n\n"
    "Troy smiled. \"We're free.\"\n\n"
    "Behind them, Planet Metron went quiet once more.\n\n"
    "It was still a prison.\n\n"
    "But it was no longer perfect.\n\n"
    "Because two brave children had escaped—and taken their hope with them, straight into the stars.\n\n";

int main(void)
{
    // Enable GPIOA clock
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    
    // Configure PA5 as output (Nucleo-F411RE user LED LD2 - heartbeat)
    GPIOA->MODER &= ~GPIO_MODER_MODER5_MASK;        // Clear mode bits for PA5
    GPIOA->MODER |= GPIO_MODER_MODER5_OUTPUT;       // Set PA5 to output mode (01)
    
    // Configure output type: push-pull (0 = default, already cleared)
    GPIOA->OTYPER &= ~(1U << 5);
    
    // Configure output speed: low (optional, 0 = default)
    GPIOA->OSPEEDR &= ~(3U << GPIO_MODER_MODER5_POS);
    
    // No pull-up/pull-down (optional, 0 = default)
    GPIOA->PUPDR &= ~(3U << GPIO_MODER_MODER5_POS);
    
    // Initialize optocoupler GPIO pins
    Optocoupler_Init();
    
    // Run optocoupler test sequence (before LCD initialization)
    // This tests each channel individually for 1 second
    Optocoupler_TestSequence();
    
    // Initialize I2C1 for LCD
    I2C1_Init();
    
    // Initialize LCD
    delay_ms(100);  // Give I2C time to stabilize
    lcd_init();
    delay_ms(10);
    
    // Clear display
    lcd_clear();
    
    // Main loop - blink LED heartbeat and stream text continuously
    uint32_t heartbeat_counter = 0;
    while (1)
    {
        // Stream the story text continuously
        // Character delay of ~30ms provides readable scrolling speed
        const char *text_ptr = story_text;
        uint8_t row = 0;
        uint8_t col = 0;
        
        while (*text_ptr)
        {
            char c = *text_ptr++;
            
            // Toggle LED heartbeat approximately every 500ms
            heartbeat_counter++;
            if (heartbeat_counter >= 17) // ~500ms at 30ms per char (500/30 ≈ 17)
            {
                GPIOA->ODR ^= GPIO_ODR_OD5;
                heartbeat_counter = 0;
            }
            
            // Skip carriage returns
            if (c == '\r')
            {
                continue;
            }
            
            // Handle newlines
            if (c == '\n')
            {
                row++;
                col = 0;
                if (row >= 4)
                {
                    // Scroll: clear display and start over
                    lcd_clear();
                    row = 0;
                    col = 0;
                    delay_ms(500); // Pause before restart
                }
                lcd_set_cursor(row, col);
                continue;
            }
            
            // Wrap at end of line
            if (col >= 20)
            {
                row++;
                col = 0;
                if (row >= 4)
                {
                    // Scroll: clear display and start over
                    lcd_clear();
                    row = 0;
                    col = 0;
                    delay_ms(500); // Pause before restart
                }
                lcd_set_cursor(row, col);
            }
            
            // Print character
            lcd_data((uint8_t)c);
            col++;
            
            // Small delay for readability (30ms per character)
            delay_ms(30);
        }
        
        // Brief pause before restarting the story
        delay_ms(2000);
        lcd_clear();
        row = 0;
        col = 0;
        heartbeat_counter = 0;
    }
}
